/*
在一个超大型社区里有 $N$ 座住宅楼（编号为 $1..N$），有 $N-1$ 条双向道路，每条道路连接两座住宅楼，从任何一座住宅楼都可以通过这些道路走到任何的另一座住宅楼。现在要给这些住宅楼贴门牌号，门牌号上当然要有编号，同时为了方便辨认，还会选择不用颜色，并且要保证有道路直接连接的两座住宅楼的颜色不同。一共有 $3$ 种颜色可以选，有些门牌号已经选好了颜色，其他的还没有选好颜色。
请你计算一下，对于那些还没有选好颜色的住宅楼，一共有多少种不同的颜色选择方案。
第一行两个整数 $N,K$。
接下来 $N-1$ 行，每行两个整数 $x,y$，表示编号为 $x$ 的住宅楼和编号为 $y$ 的住宅楼之间有一条双向道路。
接下来 $K$ 行，每行两个整数 $b,c$，表示编号为 $b$ 的住宅楼已经选好了颜色 $c$。
一个整数，表示一共有多少种不同的颜色选择方案满足要求，即有道路直接连接的两座住宅楼的颜色不同。由于答案可能很大，只需要输出答案 $\mod 10^9+7$ 的结果。
30% 的数据，$N \le 10$；
40% 的数据，$N \le 1000$；
100% 的数据，$1 \le N \le 10^5$，$0 \le K \le N$，$1 \le x,y \le N$，$x \ne y$，$1 \le b \le N$，$1 \le c \le 3$。
这道题我们先考虑30%的做法：我们可以用一个数组来记录每个点的颜色，然后每次dfs的时候，如果当前点的颜色和上一个点的颜色相同，那么就把当前点的颜色改成另外两种颜色中的一种，然后继续dfs。这样就可以保证相邻的点的颜色不同。但是这样的做法会超时，因为每次dfs都要遍历所有的边，时间复杂度是$O(n^2)$。
*/
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N = 100005;
ll n, k, ans = 1, col[N], vis[N];
vector<ll> g[N];
void dfs(ll u, ll c)
{
    vis[u] = 1;
    col[u] = c;
    for (ll i = 0; i < g[u].size(); i++)
    {
        ll v = g[u][i];
        if (!vis[v])
        {
            for (ll j = 1; j <= 3; j++)
            {
                if (j != c)
                {
                    dfs(v, j);
                    break;
                }
            }
        }
    }
}
int main()
{
    cin >> n >> k;
    for (ll i = 1; i < n; i++)
    {
        ll u, v;
        cin >> u >> v;
        g[u].push_back(v);
        g[v].push_back(u);
    }
    for (ll i = 1; i <= k; i++)
    {
        ll u, c;
        cin >> u >> c;
        col[u] = c;
        vis[u] = 1;
    }
    for (ll i = 1; i <= n; i++)
    {
        if (!vis[i])
        {
            dfs(i, 1);
            ans = ans * 3 % 1000000007;
        }
    }
    cout << ans << endl;
    return 0;
}
